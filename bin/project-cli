#!/bin/bash

# Configuration Variables
REPO_DIR="$HOME/.project-templates"
TEMPLATES_DIR="$REPO_DIR/templates"
FEATURES_DIR="$REPO_DIR/features"
VERBOSE=false

# List of filenames to ignore during the copy process
IGNORED_FILES=("README.md" "LICENSE")

# Color codes for output
INFO_COLOR='\033[0;34m'   # Blue for informational messages
PROMPT_COLOR='\033[0;32m' # Green for prompts
RED='\033[0;31m'          # Red for errors
DIM='\033[2m'
NC='\033[0m' # No color

# Arrays to keep track of file actions
skipped_files=()
merged_files=()
replaced_files=()

# Function to handle errors with detailed output
handle_error() {
  echo -e "${RED}Error: $1${NC}"
  [ -n "$2" ] && echo -e "${RED}$2${NC}"
  exit 1
}

# Function to run a command silently with dim output in verbose mode
run_command_silently() {
  local output
  output=$("$@" 2>&1)
  local status=$?

  if [ "$VERBOSE" = true ]; then
    echo -e "${DIM}${output}${NC}"
  fi

  if [ $status -ne 0 ]; then
    handle_error "Failed to run the command: $*" "$output"
  fi

  return $status
}

# Function to validate project name (kebab-case)
validate_project_name() {
  if [[ ! "$1" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]; then
    handle_error "Invalid project name. The project name must be in kebab-case (e.g., my-project-name)."
  fi
}

# Function to convert absolute path to relative path from given base directory
get_relative_path() {
  local file_path="$1"
  local base_dir="$2"
  local relative_path="${file_path#$base_dir/}"
  echo "$relative_path"
}

# Function to merge files if they already exist
merge_file() {
  local source_file="$1"
  local target_file="$2"
  local feature="$3"

  local filename=$(basename "$source_file")

  # Check if the file is in the ignored list
  if [[ " ${IGNORED_FILES[@]} " =~ " $filename " ]]; then
    echo -e "${INFO_COLOR}Ignoring $filename as it is in the ignored files list.${NC}"
    return
  fi

  if [ ! -f "$target_file" ]; then
    cp "$source_file" "$target_file"
  else
    local relative_target_path
    local relative_source_path
    relative_target_path=$(get_relative_path "$target_file" "$CURRENT_DIR")
    relative_source_path=$(get_relative_path "$source_file" "$FEATURES_DIR")

    # Ask user whether to skip, replace, or merge the file
    echo -e "\n${PROMPT_COLOR}File $relative_target_path already exists. Choose an option:${NC}"
    echo -e "${PROMPT_COLOR}1) Skip${NC}"
    echo -e "${PROMPT_COLOR}2) Replace${NC}"
    echo -e "${PROMPT_COLOR}3) Merge${NC}"
    printf "\n${PROMPT_COLOR}Enter your choice (1/2/3):${NC} "
    read -a choice

    case $choice in
    1)
      echo -e "${INFO_COLOR}Skipping source file $relative_source_path...${NC}"
      skipped_files+=("Skipped: $relative_source_path (from $feature)")
      ;;
    2)
      echo -e "${INFO_COLOR}Replacing $relative_target_path with $relative_source_path...${NC}"
      cp "$source_file" "$target_file"
      replaced_files+=("Replaced: $relative_target_path with $relative_source_path (from $feature)")
      ;;
    3)
      echo -e "${INFO_COLOR}Merging $relative_source_path into $relative_target_path...${NC}"
      if [[ "$target_file" == *.json ]]; then
        jq -s '.[0] * .[1]' "$target_file" "$source_file" >"$target_file.tmp" && mv "$target_file.tmp" "$target_file"
      else
        grep -Fxqf "$source_file" "$target_file" || cat "$source_file" >>"$target_file"
      fi
      merged_files+=("Merged: $relative_source_path into $relative_target_path (from $feature)")
      ;;
    *)
      echo -e "${RED}Invalid choice. Skipping source file $relative_source_path.${NC}"
      skipped_files+=("Skipped: $relative_source_path (from $feature) [Invalid choice]")
      ;;
    esac
  fi
}

# Interactive template selection
select_template() {
  echo -e "\n${INFO_COLOR}Available project templates:${NC}"
  templates=()
  index=1
  for dir in "$TEMPLATES_DIR"/*/; do
    template=$(basename "$dir")
    echo -e "${INFO_COLOR}$index) $template${NC}"
    templates+=("$template")
    index=$((index + 1))
  done

  printf "\n${PROMPT_COLOR}Select a project template by number:${NC} "
  read template_index
  template="${templates[$((template_index - 1))]}"

  if [ -z "$template" ]; then
    handle_error "Invalid selection. Exiting."
  fi
}

# Interactive feature selection
select_features() {
  echo -e "\n${INFO_COLOR}Available features:${NC}"
  features=()
  index=1
  for dir in "$FEATURES_DIR"/*/; do
    feature=$(basename "$dir")
    echo -e "${INFO_COLOR}$index) $feature${NC}"
    features+=("$feature")
    index=$((index + 1))
  done

  printf "\n${PROMPT_COLOR}Enter the numbers of the features you want to integrate (space-separated):${NC} "
  read -a selections

  selected_features=()
  for i in "${selections[@]}"; do
    if [[ "$i" =~ ^[0-9]+$ ]] && ((i >= 1 && i <= ${#features[@]})); then
      selected_features+=("${features[$((i - 1))]}")
    else
      echo -e "${RED}Invalid selection: $i${NC}"
    fi
  done
}

# Function to display a summary of file actions
display_file_action_summary() {
  echo -e "\n${INFO_COLOR}Summary of file actions:${NC}"
  if [ ${#skipped_files[@]} -gt 0 ]; then
    echo -e "${INFO_COLOR}Skipped files:${NC}"
    for file in "${skipped_files[@]}"; do
      echo -e "${DIM}$file${NC}"
    done
  fi

  if [ ${#replaced_files[@]} -gt 0 ]; then
    echo -e "${INFO_COLOR}Replaced files:${NC}"
    for file in "${replaced_files[@]}"; do
      echo -e "${DIM}$file${NC}"
    done
  fi

  if [ ${#merged_files[@]} -gt 0 ]; then
    echo -e "${INFO_COLOR}Merged files:${NC}"
    for file in "${merged_files[@]}"; do
      echo -e "${DIM}$file${NC}"
    done
  fi
}

# Main Logic

# Parse arguments
while [[ "$#" -gt 0 ]]; do
  case $1 in
  --verbose) VERBOSE=true ;;
  -t | --template)
    template="$2"
    shift
    ;;
  -n | --name)
    project_name="$2"
    shift
    ;;
  -f | --features)
    features="$2"
    shift
    ;;
  -h | --help)
    echo -e "${INFO_COLOR}Usage: project-cli [--verbose] [-t template] [-n project_name] [-f features]${NC}"
    exit 0
    ;;
  *) handle_error "Unknown parameter passed: $1" ;;
  esac
  shift
done

# Check for updates in the template repository
echo -e "${INFO_COLOR}Checking for updates in the template repository...${NC}"
run_command_silently git -C "$REPO_DIR" pull || handle_error "Failed to update the repository. Please check your internet connection or repository settings."
echo -e "${INFO_COLOR}Templates updated successfully.${NC}"

# If not provided via arguments, ask for template and project name
if [ -z "$template" ]; then
  select_template
fi

if [ -z "$project_name" ]; then
  while true; do
    printf "${PROMPT_COLOR}Enter the name of the new project:${NC} "
    read project_name

    validate_project_name "$project_name"

    if [ $? -eq 0 ]; then
      break
    fi
  done
else
  validate_project_name "$project_name"
fi

# Create the project directory in the current directory
CURRENT_DIR=$(pwd)
if [ -d "$TEMPLATES_DIR/$template" ]; then
  run_command_silently cp -R "$TEMPLATES_DIR/$template/." "$CURRENT_DIR/$project_name" || handle_error "Failed to create the project directory."
  echo -e "\n${INFO_COLOR}Project '$project_name' created based on template '$template' in $CURRENT_DIR.${NC}"
else
  handle_error "Template '$template' not found."
fi

# If not provided via arguments, ask for features interactively
if [ -z "$features" ]; then
  select_features
else
  IFS=',' read -ra selected_features <<<"$features"
fi

# Integrate selected features and merge files if necessary
for feature in "${selected_features[@]}"; do
  FEATURE_PATH="$FEATURES_DIR/$feature"
  if [ -d "$FEATURE_PATH" ]; then
    echo -e "\n${INFO_COLOR}Integrating $feature...${NC}"
    for file in $(find "$FEATURE_PATH" -type f); do
      filename=$(basename "$file")
      merge_file "$file" "$CURRENT_DIR/$project_name/$filename" "$feature"
    done
  else
    echo -e "${RED}Feature $feature not found.${NC}"
  fi
done

# Display a summary of file actions
display_file_action_summary

echo -e "\n${INFO_COLOR}Project setup complete.${NC}"
