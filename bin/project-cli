#!/bin/bash

# Configuration Variables
REPO_DIR="$HOME/.project-templates"
TEMPLATES_DIR="$REPO_DIR/templates"
FEATURES_DIR="$REPO_DIR/features"
VERBOSE=false

# List of filenames to ignore during the copy process
IGNORED_FILES=("README.md" "LICENSE")

# Color codes for output
INFO_COLOR='\033[0;34m'   # Blue for informational messages
PROMPT_COLOR='\033[0;32m' # Green for prompts
ERROR_COLOR='\033[0;31m'  # Red for errors
DIM='\033[2m'
NC='\033[0m' # No color

# Arrays to keep track of file actions
skipped_files=()
merged_files=()
replaced_files=()

# Global state variable for user choice
CHOICE_ALL=6

# Function to handle errors with detailed output
handle_error() {
  echo -e "${ERROR_COLOR}Error: $1${NC}"
  [ -n "$2" ] && echo -e "${ERROR_COLOR}$2${NC}"
  exit 1
}

# Function to run a command silently with dim output in verbose mode
run_command_silently() {
  local output
  output=$("$@" 2>&1)
  local status=$?

  if [ "$VERBOSE" = true ]; then
    echo -e "${DIM}${output}${NC}"
  fi

  if [ $status -ne 0 ]; then
    handle_error "Failed to run the command: $*" "$output"
  fi

  return $status
}

# Function to validate project name (kebab-case)
validate_project_name() {
  if [[ ! "$1" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]; then
    handle_error "Invalid project name. The project name must be in kebab-case (e.g., my-project-name)."
  fi
}

# Function to convert absolute path to relative path from given base directory
get_relative_path() {
  local file_path="$1"
  local base_dir="$2"
  local relative_path="${file_path#$base_dir/}"
  echo "$relative_path"
}

# Function to merge files if they already exist
merge_file() {
  local source_file="$1"
  local target_file="$2"
  local feature="$3"

  local filename=$(basename "$source_file")
  local target_dir=$(dirname "$target_file")

  # Check if the file is in the ignored list
  if [[ " ${IGNORED_FILES[@]} " =~ " $filename " ]]; then
    echo -e "${INFO_COLOR}Ignoring $filename as it is in the ignored files list.${NC}"
    return
  fi

  # Ensure the target directory exists
  if [ ! -d "$target_dir" ]; then
    mkdir -p "$target_dir"
  fi

  if [ ! -f "$target_file" ]; then
    cp "$source_file" "$target_file"
  else
    local relative_target_path
    local relative_source_path
    relative_target_path=$(get_relative_path "$target_file" "$CURRENT_DIR")
    relative_source_path=$(get_relative_path "$source_file" "$FEATURES_DIR")

    if [ -z "$CHOICE_ALL" ]; then
      # Ask user whether to skip, replace, or merge the file
      echo -e "\n${PROMPT_COLOR}File $relative_target_path already exists. Choose an option:${NC}"
      echo -e "${PROMPT_COLOR}1) Skip${NC}"
      echo -e "${PROMPT_COLOR}2) Replace${NC}"
      echo -e "${PROMPT_COLOR}3) Merge${NC}"
      echo -e "${PROMPT_COLOR}4) Skip All${NC}"
      echo -e "${PROMPT_COLOR}5) Replace All${NC}"
      echo -e "${PROMPT_COLOR}6) Merge All (default)${NC}"
      printf "\n${PROMPT_COLOR}Enter your choice (1/2/3/4/5/6):${NC} "
      read -a choice </dev/tty

      # If no input is given (i.e., user hits enter), default to "6) Merge All"
      if [ -z "${choice[0]}" ]; then
        choice[0]=6
      fi
    else
      choice[0]=$CHOICE_ALL
    fi

    case $choice in
    4)
      CHOICE_ALL=1
      choice[0]=1
      ;;
    5)
      CHOICE_ALL=2
      choice[0]=2
      ;;
    6)
      CHOICE_ALL=3
      choice[0]=3
      ;;
    esac

    case $choice in
    1)
      echo -e "${INFO_COLOR}Skipping source file $relative_source_path...${NC}"
      skipped_files+=("Skipped: $relative_source_path (from $feature)")
      ;;
    2)
      echo -e "${INFO_COLOR}Replacing $relative_target_path with $relative_source_path...${NC}"
      cp "$source_file" "$target_file"
      replaced_files+=("Replaced: $relative_target_path with $relative_source_path (from $feature)")
      ;;
    3)
      echo -e "${INFO_COLOR}Merging $relative_source_path into $relative_target_path...${NC}"
      if [[ "$target_file" == *.json ]]; then
        # Strip comments from JSON files before merging
        sed -E 's|//.*$||g; s|/\*.*\*/||g' "$target_file" >"$target_file.stripped"
        sed -E 's|//.*$||g; s|/\*.*\*/||g' "$source_file" >"$source_file.stripped"

        # Merge JSON files, concatenating arrays instead of overwriting them
        jq -s '
          def deepmerge(a; b):
            if (a | type) == "object" and (b | type) == "object" then
              reduce (b | to_entries[]) as $item (a;
                .[$item.key] = if .[$item.key] == null then $item.value
                               else deepmerge(.[$item.key]; $item.value)
                               end)
            elif (a | type) == "array" and (b | type) == "array" then
              a + b
            else
              b
            end;
          deepmerge(.[0]; .[1])' "$target_file.stripped" "$source_file.stripped" >"$target_file.tmp" && mv "$target_file.tmp" "$target_file"

        # Clean up temporary files
        rm -f "$target_file.stripped" "$source_file.stripped"
      else
        grep -Fxqf "$source_file" "$target_file" || cat "$source_file" >>"$target_file"
      fi
      merged_files+=("Merged: $relative_source_path into $relative_target_path (from $feature)")
      ;;
    *)
      echo -e "${ERROR_COLOR}Invalid choice '$choice'. Skipping source file $relative_source_path.${NC}"
      skipped_files+=("Skipped: $relative_source_path (from $feature) [Invalid choice]")
      ;;
    esac
  fi
}

# Interactive template selection
select_template() {
  echo -e "\n${INFO_COLOR}Available project templates:${NC}"
  templates=()
  index=1
  for dir in "$TEMPLATES_DIR"/*/; do
    template=$(basename "$dir")
    echo -e "${INFO_COLOR}$index) $template${NC}"
    templates+=("$template")
    index=$((index + 1))
  done

  printf "\n${PROMPT_COLOR}Select a project template by number:${NC} "
  read template_index
  template="${templates[$((template_index - 1))]}"

  if [ -z "$template" ]; then
    handle_error "Invalid selection. Exiting."
  fi
}

# Interactive feature selection
select_features() {
  echo -e "\n${INFO_COLOR}Available features:${NC}"
  features=()
  preselected=()

  index=1
  for dir in "$FEATURES_DIR"/*/; do
    feature=$(basename "$dir")

    # Check if this feature is preselected in the template configuration
    if [[ " ${enabled_features[@]} " =~ " $feature " ]]; then
      echo -e "${INFO_COLOR}$index) $feature *${NC}"
      preselected+=("$index")
    else
      echo -e "${INFO_COLOR}$index) $feature${NC}"
    fi

    features+=("$feature")
    index=$((index + 1))
  done
  echo -e "${INFO_COLOR}    (* preselected by template)${NC}"

  # Convert preselected indices to space-separated string
  preselected_string=$(
    IFS=" "
    echo "${preselected[*]}"
  )

  printf "${PROMPT_COLOR}Enter the numbers of the additional features you want to integrate (space-separated):${NC} [${preselected_string}] "
  read -r -a selections

  # If the user just hits enter, use the preselected features
  if [ -z "${selections[*]}" ]; then
    selections=("${preselected[@]}")
  else
    # Merge user selections with preselected features, avoiding duplicates
    selections=("${selections[@]}" "${preselected[@]}")
    selections=($(echo "${selections[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
  fi

  # Convert selected indices to feature names
  selected_features=()
  for i in "${selections[@]}"; do
    if [[ "$i" =~ ^[0-9]+$ ]] && ((i >= 1 && i <= ${#features[@]})); then
      selected_features+=("${features[$((i - 1))]}")
    else
      echo -e "${ERROR_COLOR}Invalid selection: $i${NC}"
    fi
  done
}

# Function to display files
display_files() {
  local label="$1"
  local files=("${!2}")

  if [ ${#files[@]} -gt 0 ]; then
    echo -e "${INFO_COLOR}${label}:${NC}"
    for file in "${files[@]}"; do
      echo -e "${DIM}$file${NC}"
    done
  fi
}

# Function to display a summary of file actions
display_file_action_summary() {
  echo -e "\n${INFO_COLOR}Summary of file actions:${NC}"
  display_files "Skipped files" skipped_files[@]
  display_files "Replaced files" replaced_files[@]
  display_files "Merged files" merged_files[@]
}

# Function to parse command-line arguments
parse_arguments() {
  while [[ "$#" -gt 0 ]]; do
    case $1 in
    --verbose) VERBOSE=true ;;
    -t | --template)
      template="$2"
      shift
      ;;
    -n | --name)
      project_name="$2"
      shift
      ;;
    -f | --features)
      features="$2"
      shift
      ;;
    -h | --help)
      echo -e "${INFO_COLOR}Usage: project-cli [--verbose] [-t template] [-n project_name] [-f features]${NC}"
      exit 0
      ;;
    *) handle_error "Unknown parameter passed: $1" ;;
    esac
    shift
  done
}

# Main Logic
main() {
  parse_arguments "$@"

  # Check for updates in the template repository
  echo -e "${INFO_COLOR}Checking for updates in the template repository...${NC}"
  run_command_silently git -C "$REPO_DIR" pull || handle_error "Failed to update the repository. Please check your internet connection or repository settings."
  echo -e "${INFO_COLOR}Templates updated successfully.${NC}"

  # If not provided via arguments, ask for template and project name
  if [ -z "$template" ]; then
    select_template
  fi

  # Path to the template configuration file
  template_config_file="$TEMPLATES_DIR/$template/project-cli.json"

  # Initialize an array for enabled features
  enabled_features=()

  # Check if the project-cli.json file exists and read it
  if [ -f "$template_config_file" ]; then
    echo -e "${INFO_COLOR}Loading template configuration from project-cli.json...${NC}"
    enabled_features=($(jq -r '.features[]' "$template_config_file"))
  fi

  if [ -z "$project_name" ]; then
    while true; do
      printf "${PROMPT_COLOR}Enter the name of the new project:${NC} "
      read project_name

      validate_project_name "$project_name"

      if [ $? -eq 0 ]; then
        break
      fi
    done
  else
    validate_project_name "$project_name"
  fi

  # Create the project directory in the current directory
  CURRENT_DIR=$(pwd)
  if [ -d "$TEMPLATES_DIR/$template" ]; then
    # Use rsync to copy the template files to the project directory, excluding project-cli.json
    run_command_silently rsync -av --exclude='project-cli.json' "$TEMPLATES_DIR/$template/" "$CURRENT_DIR/$project_name/" || handle_error "Failed to create the project directory."
    echo -e "\n${INFO_COLOR}Project '$project_name' created based on template '$template' in $CURRENT_DIR.${NC}"
  else
    handle_error "Template '$template' not found."
  fi

  # If not provided via arguments, ask for features interactively
  if [ -z "$features" ]; then
    select_features
  else
    IFS=',' read -ra selected_features <<<"$features"

    # Merge the selected features with the enabled features from the template, avoiding duplicates
    selected_features=("${selected_features[@]}" "${enabled_features[@]}")
    selected_features=($(echo "${selected_features[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
  fi

  # Integrate selected features and merge files if necessary
  for feature in "${selected_features[@]}"; do
    FEATURE_PATH="$FEATURES_DIR/$feature"
    if [ -d "$FEATURE_PATH" ]; then
      echo -e "\n${INFO_COLOR}Integrating $feature...${NC}"
      while IFS= read -r -d '' file; do
        # Calculate the relative path of the file within the feature directory
        relative_path="${file#$FEATURE_PATH/}"

        # Set the target file path by appending the relative path to the project directory
        target_file="$CURRENT_DIR/$project_name/$relative_path"

        # Call merge_file with the full source and target file paths
        merge_file "$file" "$target_file" "$feature"
      done < <(find "$FEATURE_PATH" -type f -print0)
    else
      echo -e "${ERROR_COLOR}Feature $feature not found.${NC}"
    fi
  done

  # Display a summary of file actions
  display_file_action_summary

  echo -e "\n${PROMPT_COLOR}Project setup for '$project_name' complete.${NC}\n"
}

main "$@"
