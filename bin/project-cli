#!/bin/bash

# Configuration Variables
REPO_DIR="$HOME/.project-templates"
TEMPLATES_DIR="$REPO_DIR/templates"
FEATURES_DIR="$REPO_DIR/features"
VERBOSE=false
PROJECT_CLI_CONFIG_FILE="project-cli.json"

# List of filenames to ignore during the copy process
IGNORED_FILES_TEMPLATE=("LICENSE" $PROJECT_CLI_CONFIG_FILE)
IGNORED_FILES_FEATURE=("README.md" "LICENSE")

# Color codes for output
INFO_COLOR='\033[0;34m'   # Blue for informational messages
PROMPT_COLOR='\033[0;32m' # Green for prompts
ERROR_COLOR='\033[0;31m'  # Red for errors
DIM='\033[2m'
NC='\033[0m' # No color

# Global state variable for user choice
CHOICE_ALL=6

# Function to handle errors with detailed output
handle_error() {
  echo -e "${ERROR_COLOR}Error: $1${NC}"
  [ -n "$2" ] && echo -e "${ERROR_COLOR}$2${NC}"
  exit 1
}

# Function to check if a string exists in an array
contains_element() {
  local array=("${!1}") # Access the array passed as the first argument
  local element="$2"    # The element to search for
  for item in "${array[@]}"; do
    if [[ "$item" == "$element" ]]; then
      return 0 # Found the element, return success
    fi
  done
  return 1 # Element not found, return failure
}

# Function to merge two arrays and remove duplicates
merge_arrays() {
  local array1=("${!1}")
  local array2=("${!2}")
  local merged_array=()

  # Merge array1 and array2, avoiding duplicates
  merged_array=("${array1[@]}" "${array2[@]}")
  printf '%s\n' "${merged_array[@]}" | sort -u | tr '\n' ' '
}

# Function to run a command silently with dim output in verbose mode
run_command_silently() {
  local output
  output=$("$@" 2>&1)
  local status=$?

  if [ "$VERBOSE" = true ]; then
    echo -e "${DIM}${output}${NC}"
  fi

  if [ $status -ne 0 ]; then
    handle_error "Failed to run the command: $*" "$output"
  fi

  return $status
}

# Function to convert absolute path to relative path from given base directory
get_relative_path() {
  local file_path="$1"
  local base_dir="$2"
  local relative_path="${file_path#"$base_dir"/}"
  echo "$relative_path"
}

# Merge JSON files, concatenating arrays instead of overwriting them
# Function to merge JSON files, concatenating arrays instead of overwriting them
#
# Parameters:
#   - target_file: The path to the target JSON file.
#   - source_file: The path to the source JSON file.
#
# Example usage:
#   $ ./project-cli target.json source.json
merge_json_files() {
  local target_file="$1"
  local source_file="$2"

  # Strip comments from JSON files before merging
  sed -E 's|//.*$||g; s|/\*.*\*/||g' "$target_file" >"$target_file.stripped"
  sed -E 's|//.*$||g; s|/\*.*\*/||g' "$source_file" >"$source_file.stripped"

  # This script merges two JSON files using the custom function deepmerge.
  # The deepmerge function recursively merges two JSON objects or arrays.
  # It takes two arguments: a and b, which represent the objects or arrays to be merged.
  # If both a and b are objects, the function merges their properties recursively.
  # If both a and b are arrays, the function concatenates them.
  # If either a or b is not an object or array, the function returns b.
  # The merged result is then saved to the target file.
  jq -s '
      def deepmerge(a; b):
        if (a | type) == "object" and (b | type) == "object" then
          reduce (b | to_entries[]) as $item (a;
            .[$item.key] =  if .[$item.key] == null then $item.value
                            else deepmerge(.[$item.key]; $item.value)
                            end
          )
        elif (a | type) == "array" and (b | type) == "array" then
          a + b
        else
          b
        end;
      deepmerge(.[0]; .[1])' "$target_file.stripped" "$source_file.stripped" >"$target_file.tmp" && mv "$target_file.tmp" "$target_file"

  # Clean up temporary files
  rm -f "$target_file.stripped" "$source_file.stripped"
}

# Function to merge files if they already exist
copy_or_merge_file() {
  local source_file="$1"
  local target_file="$2"
  local feature="$3"

  local target_dir
  target_dir=$(dirname "$target_file")

  # Ensure the target directory exists
  if [ ! -d "$target_dir" ]; then
    mkdir -p "$target_dir"
  fi

  if [ ! -f "$target_file" ]; then
    cp "$source_file" "$target_file"
  else
    local relative_target_path
    local relative_source_path
    relative_target_path=$(get_relative_path "$target_file" "$CURRENT_DIR")
    relative_source_path=$(get_relative_path "$source_file" "$FEATURES_DIR")

    if [ -z "$CHOICE_ALL" ]; then
      # Ask user whether to skip, replace, or merge the file
      echo -e "\n${PROMPT_COLOR}File $relative_target_path already exists. Choose an option:${NC}"
      echo -e "${PROMPT_COLOR}1) Skip${NC}"
      echo -e "${PROMPT_COLOR}2) Replace${NC}"
      echo -e "${PROMPT_COLOR}3) Merge${NC}"
      echo -e "${PROMPT_COLOR}4) Skip All${NC}"
      echo -e "${PROMPT_COLOR}5) Replace All${NC}"
      echo -e "${PROMPT_COLOR}6) Merge All (default)${NC}"
      echo -en "\n${PROMPT_COLOR}Enter your choice (1/2/3/4/5/6):${NC} "
      read -ra choice </dev/tty

      # If no input is given (i.e., user hits enter), default to "6) Merge All"
      if [ -z "${choice[0]}" ]; then
        choice[0]=6
      fi
    else
      choice[0]=$CHOICE_ALL
    fi

    case ${choice[0]} in
    4)
      CHOICE_ALL=1
      choice[0]=1
      ;;
    5)
      CHOICE_ALL=2
      choice[0]=2
      ;;
    6)
      CHOICE_ALL=3
      choice[0]=3
      ;;
    esac

    case ${choice[0]} in
    1)
      msg="Skipped: $relative_source_path (from $feature)"
      skipped_files+=("$msg")
      echo -e "${DIM}${msg}${NC}"
      ;;
    2)
      cp "$source_file" "$target_file"
      msg="Replaced: $relative_target_path with $relative_source_path (from $feature)"
      replaced_files+=("$msg")
      echo -e "${DIM}${msg}${NC}"
      ;;
    3)
      if [[ "$target_file" == *.json ]]; then
        merge_json_files "$target_file" "$source_file"
      else
        # append file
        grep -Fxqf "$source_file" "$target_file" || cat "$source_file" >>"$target_file"
      fi
      msg="Merged: $relative_source_path into $relative_target_path (from $feature)"
      merged_files+=("$msg")
      echo -e "${DIM}${msg}${NC}"
      ;;
    *)
      echo -e "${ERROR_COLOR}Invalid choice '${choice[0]}'. Skipping source file $relative_source_path.${NC}"
      skipped_files+=("Skipped: $relative_source_path (from $feature) [Invalid choice]")
      ;;
    esac
  fi
}

# Function to copy and potentially merge files
copy_and_merge_files() {
  local source_dir="$1"
  local target_dir="$2"
  local ignored_files=("${!3}")

  while IFS= read -r -d '' file; do
    # Calculate the relative path of the file within the source directory
    relative_path="${file#"$source_dir"/}"
    filename=$(basename "$file")

    # Set the target file path by appending the relative path to the project directory
    target_file="$target_dir/$relative_path"

    # Check if the file is in the ignored list
    if contains_element ignored_files[@] "$filename"; then
      echo -e "${DIM}Ignoring $filename as it is in the ignored files list.${NC}"
      continue
    fi

    # Merge the file if it already exists, otherwise just copy it
    copy_or_merge_file "$file" "$target_file"
  done < <(find "$source_dir" -type f -print0)
}

# Function to check for updates in the template repository
check_template_updates() {
  echo -e "${INFO_COLOR}Checking for updates in the template repository...${NC}"
  run_command_silently git -C "$REPO_DIR" stash || handle_error "Failed to stash changes on repository. Please check your repository settings and internet connection."
  run_command_silently git -C "$REPO_DIR" pull || handle_error "Failed to update the repository. Please check your repository settings and internet connection."
  echo -e "${INFO_COLOR}Templates updated successfully.${NC}"
}

# Function to load template configuration
load_template_config() {
  # Path to the template configuration file
  template_config_file="$TEMPLATES_DIR/$template/$PROJECT_CLI_CONFIG_FILE"

  # Initialize an array for enabled features
  enabled_features=()
  base_template=""

  # Check if the PROJECT_CLI_CONFIG_FILE file exists and read it
  if [ -f "$template_config_file" ]; then
    echo -e "${INFO_COLOR}Loading template configuration from ${PROJECT_CLI_CONFIG_FILE}...${NC}"
    sed -E 's|//.*$||g; s|/\*.*\*/||g' "$template_config_file" >"$template_config_file.stripped"
    read -ra enabled_features <<<"$(jq -r '.features[]' "$template_config_file.stripped" | tr '\n' ' ')"
    base_template=$(jq -r '.baseTemplate' "$template_config_file.stripped")
    # Clean up temporary files
    rm -f "$template_config_file.stripped"
  fi
}

# Function to validate project name (kebab-case)
validate_project_name() {
  if [[ ! "$1" =~ ^[a-z0-9]+(-[a-z0-9]+)*$ ]]; then
    handle_error "Invalid project name. The project name must be in kebab-case (e.g., my-project-name)."
  fi
}

# Function to prompt for project name and validate it
prompt_project_name() {
  if [ -z "$project_name" ]; then
    while true; do
      echo -en "${PROMPT_COLOR}Enter the name of the new project:${NC} "
      read -r project_name

      if validate_project_name "$project_name"; then
        break
      fi
    done
  else
    validate_project_name "$project_name"
  fi
}

# Function to create the project directory and copy template files
create_project() {
  local template="$1"
  local project_name="$2"

  # Create the project directory in the current directory
  if [ -d "$CURRENT_DIR/$project_name" ]; then
    handle_error "Project directory '$project_name' already exists in $CURRENT_DIR."
  fi

  mkdir "$CURRENT_DIR/$project_name" || handle_error "Failed to create the project directory."

  # Copy the base template if specified
  if [ -n "$base_template" ]; then
    echo -e "${INFO_COLOR}Copying base template '$base_template'...${NC}"
    if [ -d "$TEMPLATES_DIR/$base_template" ]; then
      copy_and_merge_files "$TEMPLATES_DIR/$base_template" "$CURRENT_DIR/$project_name" IGNORED_FILES_TEMPLATE[@]
    else
      handle_error "Base template '$base_template' not found."
    fi
  fi
  # ! TODO add features from baseTemplate to enabled_features

  # Copy the selected template files
  if [ -d "$TEMPLATES_DIR/$template" ]; then
    copy_and_merge_files "$TEMPLATES_DIR/$template" "$CURRENT_DIR/$project_name" IGNORED_FILES_TEMPLATE[@]
    echo -e "\n${INFO_COLOR}Project '$project_name' created based on template '$template' in $CURRENT_DIR.${NC}"
  else
    handle_error "Template '$template' not found."
  fi
}

# Interactive template selection
select_template() {
  echo -e "\n${INFO_COLOR}Available project templates:${NC}"
  templates=()
  index=1
  for dir in "$TEMPLATES_DIR"/*/; do
    template=$(basename "$dir")
    echo -e "${INFO_COLOR}$index) $template${NC}"
    templates+=("$template")
    index=$((index + 1))
  done

  echo -en "\n${PROMPT_COLOR}Select a project template by number:${NC} "
  read -r template_index
  template="${templates[$((template_index - 1))]}"

  if [ -z "$template" ]; then
    handle_error "Invalid selection. Exiting."
  fi
}

# Interactive feature selection
select_features() {
  echo -e "\n${INFO_COLOR}Available features:${NC}"
  features=()
  preselected=()

  index=1
  for dir in "$FEATURES_DIR"/*/; do
    feature=$(basename "$dir")

    # Check if this feature is preselected in the template configuration
    if contains_element enabled_features[@] "$feature"; then
      echo -e "${INFO_COLOR}$index) $feature *${NC}"
      preselected+=("$index")
    else
      echo -e "${INFO_COLOR}$index) $feature${NC}"
    fi

    features+=("$feature")
    index=$((index + 1))
  done
  echo -e "${INFO_COLOR}    (* preselected by template)${NC}"

  # Convert preselected indices to space-separated string
  preselected_string=$(
    IFS=" "
    echo "${preselected[*]}"
  )

  echo -en "${PROMPT_COLOR}Enter the numbers of the additional features you want to integrate (space-separated):${NC} [${preselected_string}] "
  read -ra selections

  # If the user just hits enter, use the preselected features
  if [ -z "${selections[*]}" ]; then
    selections=("${preselected[@]}")
  else
    # Merge user selections with preselected features, avoiding duplicates
    read -ra selections <<<"$(merge_arrays selections[@] preselected[@])"
  fi

  # Convert selected indices to feature names
  selected_features=()
  for i in "${selections[@]}"; do
    if [[ "$i" =~ ^[0-9]+$ ]] && ((i >= 1 && i <= ${#features[@]})); then
      selected_features+=("${features[$((i - 1))]}")
    else
      echo -e "${ERROR_COLOR}Invalid selection: $i${NC}"
    fi
  done
}

# Function to integrate selected features and merge files
integrate_features() {
  local selected_features=("$@")
  local filename
  local relative_path
  local target_file

  for feature in "${selected_features[@]}"; do
    FEATURE_PATH="$FEATURES_DIR/$feature"
    if [ -d "$FEATURE_PATH" ]; then
      echo -e "\n${INFO_COLOR}Integrating $feature...${NC}"
      copy_and_merge_files "$FEATURE_PATH" "$CURRENT_DIR/$project_name" IGNORED_FILES_FEATURE[@]
    else
      echo -e "${ERROR_COLOR}Feature $feature not found.${NC}"
    fi
  done
}

# Function to display files
display_files() {
  local label="$1"
  local files=("${!2}")

  if [ ${#files[@]} -gt 0 ]; then
    echo -e "${INFO_COLOR}${label}:${NC}"
    for file in "${files[@]}"; do
      echo -e "${DIM}$file${NC}"
    done
  fi
}

# Function to display a summary of file actions
display_file_action_summary() {
  echo -e "\n${INFO_COLOR}Summary of file actions:${NC}"
  display_files "Skipped files" skipped_files[@]
  display_files "Replaced files" replaced_files[@]
  display_files "Merged files" merged_files[@]
}

# Function to parse command-line arguments
parse_arguments() {
  while [[ "$#" -gt 0 ]]; do
    case $1 in
    --verbose) VERBOSE=true ;;
    -t | --template)
      template="$2"
      shift
      ;;
    -n | --name)
      project_name="$2"
      shift
      ;;
    -f | --features)
      IFS=',' read -ra features <<<"$2"
      shift
      ;;
    -h | --help)
      echo -e "${INFO_COLOR}Usage: project-cli [--verbose] [-t template] [-n project_name] [-f features]${NC}"
      exit 0
      ;;
    *) handle_error "Unknown parameter passed: $1" ;;
    esac
    shift
  done
}

# Arrays to keep track of file actions
skipped_files=()
merged_files=()
replaced_files=()

# Main Logic
main() {
  CURRENT_DIR=$(pwd)

  parse_arguments "$@"

  # Check for updates in the template repository
  check_template_updates

  # If not provided via arguments, ask for template selection interactively
  if [ -z "$template" ]; then
    select_template
  fi

  # Load template configuration
  load_template_config

  # Call the prompt_project_name function
  prompt_project_name

  # Create the project directory and copy template files
  create_project "$template" "$project_name"

  # If not provided via arguments, ask for features interactively
  selected_features=()
  if [ -z "${features[0]}" ]; then
    select_features
  else
    # Merge the selected features with the enabled features from the template
    read -ra selected_features <<<"$(merge_arrays features[@] enabled_features[@])"
  fi

  # Call the integrate_features function with the selected features
  integrate_features "${selected_features[@]}"

  # Display a summary of file actions
  display_file_action_summary

  echo -e "\n${PROMPT_COLOR}Project setup for '$project_name' complete.${NC}\n"
}

main "$@"
